<p>In machine learning, you start by defining a task and a model. The model consists of an architecture and parameters. For a given architecture, the values of the parameters determine how accurately the model performs the task. 
But how do you find good values? By defining a loss function that evaluates how well the model performs. The goal is to optimize the loss and thereby to find parameter values that match predictions with reality. This is the essence of training.</p>

<h1 id="I">I Setting up the optimization problem</h1>

<p>The loss function will be different in different tasks depending on the output desired. How you define it has a major influence on how the model will train and perform. Let’s consider two examples:</p>

<h3 id="example-1-house-price-prediction">Example 1: House price prediction</h3>

<p>Say your task is to predict the price of houses y \in \mathbb{R}y∈R based on features such as floor area, number of bedrooms, and ceiling height. The loss function can be summarized by the sentence:</p>

<blockquote>
  <p>Given a set of house features, the square of the difference between your prediction and the actual price should be as small as possible.</p>
</blockquote>

<p>You define the loss function as</p>

<table>
  <tbody>
    <tr>
      <td>\mathcal{L} =</td>
      <td> </td>
      <td>y-\hat{y}</td>
      <td> </td>
      <td>_2^2L=∣∣y−y^​∣∣22​</td>
    </tr>
  </tbody>
</table>

<p>where \hat{y}y^​ is your predicted price and yy is the actual price, also known as ground truth.</p>

<h3 id="example-2-object-localization">Example 2: Object localization</h3>

<p>Let’s consider a more complex example. Say your task is to localize the car in a set of images that contain one. The loss function should frame the following sentence in mathematical terms:</p>

<blockquote>
  <p>Given an image containing one car, predict a bounding box (bbox) that surrounds the vehicle. The predicted box should match the size and position of the actual car as closely as possible.</p>
</blockquote>

<p>In mathematical terms, a possible loss function \mathcal{L}L (Redmon et al., 2016) is:</p>

<p>\mathcal{L} = \underbrace{(x - \hat{x})^2 + (y - \hat{y})^2}<em>{\text{BBox Center}} + \underbrace{(w - \hat{w})^2 + (h - \hat{h})^2}</em>{\text{BBox Width/Height}}L=(+(</p>

<p>This <span class="sidenote">loss function</span> depends on:</p>

<ol>
  <li>The model’s prediction which, in turn, depends on the parameter values  (weights and biases) as well as the input (in this case, images)</li>
  <li>The ground truth corresponding to the input (labels; in this case, bounding boxes)</li>
</ol>

<h3 id="visualizing-the-loss-function">Visualizing the loss function</h3>

<p>For a given input batch along with the corresponding ground truths, the loss function has a landscape that depends on the parameters of the network.</p>

<p>It is difficult to visualize this landscape, if there are more than two parameters. However, the landscape does exist, and our goal is to find the point where the loss function’s value is minimal.</p>

<p>Updating the parameter values will move the value either closer to or farther from the target minimum point.</p>

<h3 id="the-relationship-between-the-model-and-the-loss-function">The relationship between the model and the loss function</h3>

<p>It is important to distinguish between the function f that will perform the task (the model) and the function \mathcal{L} you are optimizing (the loss function).</p>

<ol>
  <li>The model is an architecture and a set of parameters that approximates a <span class="sidenote">real function</span>that performs the task. Optimized parameter values will enable the model to perform the task with relative accuracy.</li>
  <li>The loss function quantifies how accurately the model has performed on given data set. Its value depends on the model’s parameter values.</li>
</ol>

<p>At this point, good parameter values are unknown. However, you have a formula for the loss function. Optimize that on your dataset, and theoretically you will find good parameter values. The way to do this is to feed a training data set into the model and adjust the parameters iteratively to make the loss function as small as possible.</p>

<p>In summary, the way you define the loss function will dictate the performance of your model on the task at hand. The diagram below illustrates the process of finding a model that performs well.</p>

<h1 id="I">II Running the optimization process</h1>

<p>In this section, we assume that you have chosen a task, a data set, and a loss function. You will minimize the loss on the data set to find good parameter values.</p>

<h3 id="using-gradient-descent">Using gradient descent</h3>

<p>First, you must initialize the parameter values so you have a starting point for optimization. Then, you will adjust the parameter values using gradient descent to reduce the value of the loss function.</p>

<p>Gradient descent is an iterative optimization algorithm that finds the minimum of a function. In machine learning, that means minimizing the loss. At every iteration, parameter values are adjusted according to the opposite direction of the gradient of the loss; that is, in the direction that reduces the loss.</p>

<p>The formula to remember is:</p>

<div class="kdmath">$$
W = W - \alpha \frac{\partial \mathcal{L}}{\partial W}
$$</div>

<p>Where:</p>

<ol>
  <li>$W$ denotes the parameters</li>
  <li>$\frac{\partial \mathcal{L}}{\partial W}$ is a gradient indicating the direction to push the value of $W$ in order to decrease $\mathcal{L}$.</li>
  <li>$\alpha$ is the learning rate which you can tune to decide how much you want to adjust the value of $W$.</li>
</ol>

<p>You can learn more about gradient-based optimization algorithms in the Deep Learning Specialization. This topic is covered in Course 1, Week 2 (Logistic Regression as a Neural Network) and Course 2, Week 2 (Optimization Algorithms).</p>

<h3 id="adjusting-gradient-descent-hyperparameters">Adjusting gradient descent hyperparameters</h3>

<p>To use gradient descent, you must choose values for hyperparameters such as learning rate and batch size. These values will influence the optimization, so it’s important to set them appropriately.</p>

<p>In the visualization below, you can play with the starting point of initialization, learning rate, and batch size. With these hyperparameters, you will fit a linear model <span class="kdmath">$\hat{y} = wa x + b$</span> (for the sake of simplicity) on a set of 300 data points using gradient descent.</p>

<p>Here are some questions to consider as you explore the visualization:</p>

<p>What is the impact of the training set size?</p>

<p>What is the impact of the learning rate on the optimization?</p>

<p>What is the impact of the batch size on the optimization?</p>

<p>Why does the loss landscape look like this?</p>

<p>Why do the model parameters converge to values different than those of the ground-truth slope and intercept?</p>

<div class="visualization hide-backToTop" id="regression">
    <div class="visualization-column-1">
        <h3>1. Generate your dataset</h3>
        <p>Select a training set size.</p>
        <label class="radio-container">Small
            <input type="radio" value="20" name="regression_tsize" />
            <span class="checkmark"></span>
        </label>
        <label class="radio-container">Medium
            <input type="radio" value="300" name="regression_tsize" checked="" />
            <span class="checkmark"></span>
        </label>
        <label class="radio-container">Large
            <input type="radio" value="800" name="regression_tsize" />
            <span class="checkmark"></span>
        </label>
        <p>A training set of the chosen size will be sampled with noise from a <span class="blue">"ground truth"</span> line. This line is the target line for your <span class="red">network function</span> defined by <script>document.write(katex.renderToString('\\hat{y} = wx + b'))</script>.</p>
        <div id="regression_plot" style="margin-top:1em;border: 1px solid rgba(0,0,0,0.2);"></div>
        <button class="button-transport" id="generate">
           Generate a new <span class="blue">"ground truth"</span> line
        </button>
    </div>
    <div class="visualization-column-2">
        <h3>2. Observe the loss landscape and initialize parameters</h3>
        <p>The loss function is the L2 loss defined as <script>document.write(katex.renderToString('\\mathcal{L}(y, \\hat{y}) = ||y - \\hat{y}||_2^2'))</script>. The <span class="blue">blue dot</span> indicates the value of the loss function at the "ground truth" slope and intercept. The <span class="red">red dot</span> indicates the value of the loss function at a chosen initialization of the slope and intercept. Drag and drop the red dot to change the initialization.</p>
        <div id="regression_landscape"></div>
    </div>
    <div class="visualization-column-1">
        <h3>3. Optimize your loss function</h3>
        <p>You can now iteratively update your parameters to minimize the loss. Select a learning rate.</p>
        <label class="radio-container">Small
            <input type="radio" value="0.0001" name="regression_lrate" />
            <span class="checkmark"></span>
        </label>
        <label class="radio-container">Medium
            <input type="radio" value="0.01" name="regression_lrate" checked="" />
            <span class="checkmark"></span>
        </label>
        <label class="radio-container">Large
            <input type="radio" value="0.1" name="regression_lrate" />
            <span class="checkmark"></span>
        </label>
        <p>Select a batch size to use.</p>
        <label class="radio-container">Stochastic
            <input type="radio" value="1" name="regression_bsize" checked="" />
            <span class="checkmark"></span>
        </label>
        <label class="radio-container">Mini-batch
            <input type="radio" value="30" name="regression_bsize" />
            <span class="checkmark"></span>
        </label>
        <label class="radio-container">Full-batch
            <input type="radio" value="300" name="regression_bsize" />
            <span class="checkmark"></span>
        </label>
        <p>Train your <span class="red">network function</span>.</p>
        <button class="button-transport" id="regression_reset" title="reset">
            <img src="/assets/images/layout/reset.png" />
        </button>
        <button class="button-transport" id="regression_train" title="start">
            <img src="/assets/images/layout/play.png" />
        </button>
        <button class="button-transport hidden" id="regression_stop" title="stop">
            <img src="/assets/images/layout/pause.png" />
        </button>
        <div id="regression_loss"></div>
    </div>
</div>

<p>Note that the loss $\mathcal{L}$ takes as input a single example, so minimizing it doesn’t guarantee better model parameters for other examples. It is common to minimize the average of the loss computed over a batch of examples; for instance, $\mathcal{J} = \frac{1}{m_b} \sum_{i=1}^{m_b} \mathcal{L}^{(i)}$. We call this function the cost, and reducing it leads to a more accurate parameter-update direction to minimize training error. $m_b$  is called the batch size. This is a key <span class="sidenote">hyperparameter</span> to tune.</p>

<p>Here are some takeaways from the visualization:</p>

<h3 id="initialization">Initialization</h3>

<p>A good initialization can accelerate optimization and enable it to converge to the minimum or, if there are several minima, the best one. To learn more about initialization, read our AI Note on initializing neural networks.</p>

<h3 id="learning-rate">Learning rate</h3>

<p>The learning rate influences the optimization’s convergence. It also counterbalances the influence of the loss function’s curvature. According to the gradient descent formula above, the direction and magnitude of the parameter update is given by the learning rate multiplied by the slope of the loss function at a certain point $W$. Specifically: $\alpha \frac{\partial \mathcal{L}}{\partial W}$.</p>

<p>If the learning rate is too small, updates are small and optimization is slow, especially if the loss curvature is low. Also, you’re likely to settle into an <span class="sidenote">inappropriate local minimum<span>.</span></span></p>

<p>If the learning rate is too large, updates will be large and the optimization is likely to diverge, especially if the loss curvature is high.</p>

<p>If the learning rate is good, updates are appropriate and the optimization should converge.</p>

<p>Play with the visualization below to understand the influence of the learning rate and the loss curvature on the convergence of your algorithm.</p>

<svg id="loss" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600">
  <title>quadratic_curve</title>
  <rect id="frame" width="800" height="600" fill="none" />
  <g id="UI">
    <text transform="translate(591.28 299.22)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.01em" style="isolation: isolate">Learning Rate:</text>
    <circle id="curve_sel" data-name="curve sel" cx="602.79" cy="243.81" r="4.76" fill="#5ea0fa" />
    <circle id="rate_sel" data-name="rate sel" cx="602.79" cy="321.87" r="4.76" fill="#5ea0fa" />
    <circle id="curve_sel-2" data-name="curve sel-2" cx="670.94" cy="243.81" r="4.76" fill="#5ea0fa" />
    <circle id="rate_sel-2" data-name="rate sel-2" cx="670.94" cy="321.87" r="4.76" fill="#5ea0fa" />
    <circle id="lo_toggle" data-name="lo toggle" cx="602.79" cy="243.81" r="8.65" fill="none" stroke="#c6c6c6" stroke-miterlimit="10" stroke-width="2" />
    <circle id="hi_toggle" data-name="hi toggle" cx="670.94" cy="243.81" r="8.65" fill="#fff" stroke="#c6c6c6" stroke-miterlimit="10" stroke-width="2" />
    <circle id="big_toggle" data-name="big toggle" cx="670.94" cy="321.87" r="8.65" fill="none" stroke="#c6c6c6" stroke-miterlimit="10" stroke-width="2" />
    <circle id="sm_toggle" data-name="sm toggle" cx="602.79" cy="321.87" r="8.65" fill="#fff" stroke="#c6c6c6" stroke-miterlimit="10" stroke-width="2" />
    <text transform="translate(615.44 247.32)" font-size="12" font-family="Roboto-Regular, Roboto" style="isolation: isolate">Low</text>
    <text transform="translate(683.59 247.32)" font-size="12" font-family="Roboto-Regular, Roboto" style="isolation: isolate">High</text>
    <text transform="translate(615.44 326.63)" font-size="12" font-family="Roboto-Regular, Roboto" style="isolation: isolate">Small</text>
    <text transform="translate(683.59 326.63)" font-size="12" font-family="Roboto-Regular, Roboto" style="isolation: isolate">La<tspan x="12.98" y="0" letter-spacing="-0.01em">r</tspan><tspan x="16.93" y="0">ge</tspan></text>
    <g id="replay">
      <path d="M602.47,368.51h37.86a9.2,9.2,0,0,1,9.2,9.2h0a9.2,9.2,0,0,1-9.2,9.2H602.47a9.2,9.2,0,0,1-9.2-9.2h0a9.2,9.2,0,0,1,9.2-9.2Z" fill="#636363" />
      <g>
        <path d="M604.39,382.22a4.52,4.52,0,1,1,2.92-8l-.68.67a.25.25,0,0,0,0,.34.24.24,0,0,0,.11.06l3.23.87a.24.24,0,0,0,.29-.17.29.29,0,0,0,0-.13l-.9-3.22a.23.23,0,0,0-.27-.17h0a.21.21,0,0,0-.1.06l-.66.66a6,6,0,1,0,.56,8.47,5.68,5.68,0,0,0,.59-.8.47.47,0,0,0-.14-.65h0l-.48-.23a.5.5,0,0,0-.61.15A4.46,4.46,0,0,1,604.39,382.22Z" fill="#fff" />
        <g>
          <text transform="translate(613.2 380.6)" font-size="9.9" fill="#fff" font-family="Roboto-Regular, Roboto" letter-spacing="-0.01em" style="isolation: isolate">Resta</text>
          <text transform="translate(637.78 380.6)" font-size="9.9" fill="#fff" font-family="Roboto-Regular, Roboto" letter-spacing="0.01em" style="isolation: isolate">r</text>
          <text transform="translate(641.27 380.6)" font-size="9.9" fill="#fff" font-family="Roboto-Regular, Roboto" letter-spacing="-0.01em" style="isolation: isolate">t</text>
        </g>
      </g>
    </g>
    <text id="iter_text" data-name="iter text" transform="translate(591.28 176.11)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.01em" style="isolation: isolate">Ite<tspan x="13.46" y="0" letter-spacing="-0.02em">r</tspan><tspan x="17.38" y="0">ation: 0</tspan></text>
    <g>
      <g>
        <line x1="604.08" y1="453.51" x2="626" y2="453.51" fill="none" stroke="#ff1e00" stroke-linecap="round" stroke-miterlimit="10" stroke-width="3" />
        <text transform="translate(636.64 449.81)" font-size="10" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.01em">Er<tspan x="8.97" y="0" letter-spacing="-0.03em">r</tspan><tspan x="12.21" y="0" letter-spacing="-0.01em">or of </tspan><tspan letter-spacing="-0.03em"><tspan x="0" y="12">A</tspan><tspan x="6.32" y="12" letter-spacing="-0.01em">pp</tspan><tspan x="17.38" y="12" letter-spacing="-0.03em">r</tspan><tspan x="20.62" y="12" letter-spacing="-0.02em">o</tspan><tspan x="26.11" y="12" letter-spacing="-0.01em">ximation</tspan></tspan></text>
      </g>
      <rect x="593.27" y="430.5" width="118.32" height="44.79" rx="4.18" fill="none" stroke="#c6c6c6" stroke-miterlimit="10" />
    </g>
    <g>
      <text transform="translate(591.28 221.16)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.01em" style="isolation: isolate">Loss</text>
      <text transform="translate(619.38 221.16)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.02em" style="isolation: isolate">F</text>
      <text transform="translate(625.72 221.16)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.01em" style="isolation: isolate">unction Cu</text>
      <text transform="translate(682.2 221.16)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" style="isolation: isolate">r</text>
      <text transform="translate(686.4 221.16)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.02em" style="isolation: isolate">v</text>
      <text transform="translate(692.13 221.16)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.01em" style="isolation: isolate">atu</text>
      <text transform="translate(708.92 221.16)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.02em" style="isolation: isolate">r</text>
      <text transform="translate(712.91 221.16)" font-size="12" font-family="Roboto-Medium, Roboto" font-weight="500" letter-spacing="-0.01em" style="isolation: isolate">e:</text>
    </g>
  </g>
  <g id="loss_graph" data-name="loss graph">
    <g id="axes">
      <line id="bottomLine" x1="61.48" y1="475.65" x2="523.48" y2="475.65" fill="none" stroke="#aaa" stroke-miterlimit="10" stroke-width="3" />
      <line id="vert" x1="61.48" y1="475.65" x2="61.48" y2="128.55" fill="none" stroke="#aaa" stroke-miterlimit="10" stroke-width="3" />
      <polygon id="left_arr" data-name="left arr" points="521.68 470.15 521.68 480.35 532.08 475.65 521.68 470.15" fill="#aaa" />
      <polygon id="up_arr" data-name="up arr" points="56.38 130.05 66.68 130.05 61.88 119.65 56.38 130.05" fill="#aaa" />
    </g>
    <line id="errorLine" x1="41.94" y1="17.8" x2="41.94" y2="17.8" fill="none" stroke="#ff1e00" stroke-miterlimit="10" stroke-width="3" />
    <path id="flat_curve" data-name="flat curve" d="M93.22,170.88s95.32,239.34,218.32,239.34S529.85,170.88,529.85,170.88" fill="none" stroke="#2665ba" stroke-linecap="round" stroke-miterlimit="10" stroke-width="3" />
    <path id="steep_curve" data-name="steep curve" d="M166.62,170.88S229.9,410.22,311.54,410.22,456.45,170.88,456.45,170.88" fill="none" stroke="#2665ba" stroke-linecap="round" stroke-miterlimit="10" stroke-width="3" />
    <line id="deriv" x1="523.48" y1="410.22" x2="99.59" y2="410.22" fill="none" stroke="red" stroke-miterlimit="10" stroke-width="3" />
    <line id="ph_deriv" data-name="ph deriv" x1="523.48" y1="410.22" x2="99.59" y2="410.22" fill="none" stroke="#ffa600" stroke-linecap="round" stroke-miterlimit="10" stroke-width="3" />
    <line id="learnLine" x1="41.94" y1="17.8" x2="41.94" y2="17.8" fill="none" stroke="#d45087" stroke-linecap="round" stroke-miterlimit="10" stroke-width="4" />
    <circle id="cloneDot" cx="311.54" cy="410.22" r="6.66" fill="#ff7c43" />
    <circle id="phDot" cx="311.54" cy="410.22" r="6.66" fill="none" />
    <circle id="centerDot" cx="311.54" cy="410.22" r="6.66" fill="#5ea0fa" />
    <g id="errorText">
      <rect id="text_frame" data-name="text frame" y="0.08" width="101.22" height="39.91" rx="9.08" fill="#ededed" />
      <g>
        <text transform="translate(11.53 16.34)" font-size="12" font-family="Roboto-Regular, Roboto" style="isolation: isolate">Er</text>
        <text transform="translate(22.41 16.34)" font-size="12" font-family="Roboto-Regular, Roboto" letter-spacing="-0.01em" style="isolation: isolate">r</text>
        <text transform="translate(26.35 16.34)" font-size="12" font-family="Roboto-Regular, Roboto" style="isolation: isolate">or of</text>
        <text transform="translate(11.53 30.74)" font-size="12" font-family="Roboto-Regular, Roboto" style="isolation: isolate">App</text>
        <text transform="translate(32.82 30.74)" font-size="12" font-family="Roboto-Regular, Roboto" letter-spacing="-0.01em" style="isolation: isolate">r</text>
        <text transform="translate(36.77 30.74)" font-size="12" font-family="Roboto-Regular, Roboto" letter-spacing="-0.01em" style="isolation: isolate">o</text>
        <text transform="translate(43.49 30.74)" font-size="12" font-family="Roboto-Regular, Roboto" style="isolation: isolate">ximation</text>
      </g>
    </g>
    <text transform="translate(10.35 130.05)" font-size="15" fill="#878787" font-family="Roboto-Regular, Roboto" style="isolation: isolate">Loss</text>
    <g>
      <text transform="translate(483.95 505.12)" font-size="15" fill="#878787" font-family="Roboto-Regular, Roboto" letter-spacing="-0.01em" style="isolation: isolate">P</text>
      <text transform="translate(493.33 505.12)" font-size="15" fill="#878787" font-family="Roboto-Regular, Roboto" style="isolation: isolate">a</text>
      <text transform="translate(501.49 505.12)" font-size="15" fill="#878787" font-family="Roboto-Regular, Roboto" letter-spacing="-0.02em" style="isolation: isolate">r</text>
      <text transform="translate(506.27 505.12)" font-size="15" fill="#878787" font-family="Roboto-Regular, Roboto" style="isolation: isolate">ameters</text>
    </g>
  </g>
</svg>

<p>Takeaways from the visualization:</p>

<p>The choice of learning rate depends on the curvature of the loss function.</p>

<p>Gradient descent makes a linear approximation of the loss function at a given point. Then it moves downhill along the approximation of the loss function.</p>

<p>If the loss is highly curved, the larger the learning rate (step size), the larger the error of the <span class="sidenote">gradient approximation<span>. The approximation tends to overshoot.</span></span></p>

<p>Taking small steps reduces the gradient approximation error.</p>

<p>It is common to start with a large learning rate and decay it during training. Learning rates depend on the application; values between 0.1 and 1 are usually considered large. Choosing the right decay (how often? by how much?) is non-trivial. An excessively aggressive decay schedule slows progress toward the optimum, while a slow-paced decay schedule leads to chaotic updates with small improvements.</p>

<p>In fact, nobody knows the right decay schedule. However, adaptive learning-rate algorithms such as Momentum Adam and RMSprop help adjust the learning rate during the optimization process. We’ll explain those algorithms below.</p>

<h3 id="batch-size">Batch size</h3>

<p>Batch size is the number of data points used to train a model in each iteration. Typical small batches are 32, 64, 128, 256, 512, while large batches can be thousands of examples.</p>

<p>Choosing the right batch size is crucial to ensure convergence of the loss function and parameter values, and to the generalization of your model. Research2 has considered how to make the choice, but there is no consensus. In practice, you can use a <span class="sidenote">hyperparameter search<span>.</span></span></p>

<p>Research into batch size has revealed the following principles:</p>

<p>Batch size determines the frequency of updates. The smaller the batches, the more — though quicker — the updates.</p>

<p>The larger the batch size, the more accurate the gradient of the loss will be with respect to the parameters. That is, the direction of the update is most likely going down the local 
slope of the loss landscape.</p>

<p>The largest batch size that fits into GPU memory leads to efficient parallelization and usually accelerates training.</p>

<p>However, in practice, large batch sizes can hurt the model’s ability to generalize.</p>

<p>In choosing batch size, there’s a balance to be struck depending on the available computational hardware and the task you’re trying to achieve. Recall that the input batch is an input to the cost function. Large batch size typically leads to sharper cost function surfaces than a small batch size, as Keskar et al. find in their paper, “On large-batch training for deep learning: generalization gap and sharp minima.”</p>

<p>Here’s a figure comparing a flat and a sharp minimum. Flat cost surfaces (and thus small batch sizes) are preferred because they lead to good generalization without requiring high precision.</p>

<p>In practice, hyperparameter search can help you find batch size and learning rate. These hyperparameters are two routes to the same outcome, according to Smith, Kindermans et al. in Don’t Decay the Learning Rate, Increase the Batch Size. They argue that the benefits of decaying the learning rate can be achieved by increasing batch size during training. So if you change batch size, you may also need to change learning rate. Efficient use of vast batch sizes notably reduces the number of parameter updates required to train a model.</p>

<h3 id="iterative-update">Iterative update</h3>

<p>Now that you have a starting point, a learning rate, and a batch size, it’s time to update the parameters iteratively to move toward the cost function’s minimum.</p>

<p>The optimization algorithm is also a core choice. You can play with various optimizers in the visualization below. That will help you build an intuitive sense of the pros and cons of each.</p>

<p>In this visualization, your goal is to play with hyperparameters to find parameter values that minimize a loss function. You can choose the loss function and starting point of the optimization. Although there’s no explicit model, you can assume that finding the minimum of the loss function is equivalent to finding the best model for your task. For the sake of simplicity, the model only has two parameters and the batch batch size is always 1.</p>

<div class="visualization hide-backToTop" id="landscape">
    <div class="visualization-column-2">
        <p>In this visualization, you will choose the loss function and the starting point of your optimization. Although there's no explicit network function, you can assume that finding the minimum of your loss function is equivalent to finding the best network function for your task.</p>

        <h3>1. Choose a loss landscape</h3>
        <p>Select an <a href="https://en.wikipedia.org/wiki/Test_functions_for_optimization">artificial landscape</a> $\mathcal{L}(w_1,w_2)$.</p>
        <div class="lossFunctions">
            <label>
              <input type="radio" name="loss" value="himmelblaus" checked="" />
              <img src="/assets/images/article/optimization/loss/himmelblaus.png" />
            </label>
            <label>
              <input type="radio" name="loss" value="styblinskiTang" />
              <img src="/assets/images/article/optimization/loss/styblinskiTang.png" />
            </label>
            <label>
              <input type="radio" name="loss" value="rosenbrock" />
              <img src="/assets/images/article/optimization/loss/rosenbrock.png" />
            </label>
            <label>
              <input type="radio" name="loss" value="goldsteinPrice" />
              <img src="/assets/images/article/optimization/loss/goldsteinPrice.png" />
            </label>
        </div>
        <h3>2. Choose initial parameters</h3>
        <p>On the loss landscape graph, drag the <font color="red">red dot</font> to choose the initial parameters values and thus the initial value of the loss.</p>

        <h3>3. Choose an optimizer</h3>
        <p>Select the optimizer and its hyperparameters.</p>


        <table>
          <tr>
            <th>Optimizer</th>
            <th>Learning Rate</th> 
            <th>Learning Rate Decay</th>
          </tr>
          <tr>
            <td>
                <div class="checkbox">
                    <input type="checkbox" name="opt" value="gd" checked="" />
                    <label>Gradient Descent</label>
                </div>
                
            </td>
            <td><input class="gd" type="number" name="lrate" value="0.001" min="0" max="1" step="0.0001" /></td>
            <td><input class="gd" type="number" name="ldecay" value="0" min="0" max="1" step="0.01" /></td>
          </tr>
          <tr>
            <td><input type="checkbox" name="opt" value="momentum" checked="" /> Momentum</td>
            <td><input class="momentum" type="number" name="lrate" value="0.001" min="0" max="1" step="0.0001" /></td>
            <td><input class="momentum" type="number" name="ldecay" value="0" min="0" max="1" step="0.01" /></td>
          </tr>
          <tr>
            <td><input type="checkbox" name="opt" value="rmsprop" checked="" /> RMSprop</td>
            <td><input class="rmsprop" type="number" name="lrate" value="0.001" min="0" max="1" step="0.0001" /></td>
            <td><input class="rmsprop" type="number" name="ldecay" value="0" min="0" max="1" step="0.01" /></td>
          </tr>
          <tr>
            <td><input type="checkbox" name="opt" value="adam" checked="" /> Adam</td>
            <td><input class="adam" type="number" name="lrate" value="0.001" min="0" max="1" step="0.0001" /></td>
            <td><input class="adam" type="number" name="ldecay" value="0" min="0" max="1" step="0.01" /></td>
          </tr>
        </table>
        <p>Optimize your loss function.</p>
        <button class="button-transport" id="reset" title="reset">
            <img src="/assets/images/layout/reset.png" />
        </button>
        <button class="button-transport" id="train" title="start">
            <img src="/assets/images/layout/play.png" />
        </button>
        <button class="button-transport hidden" id="stop" title="stop">
            <img src="/assets/images/layout/pause.png" />
        </button>
    </div>
    <div class="visualization-column-2">
        <p> This 2D plot describes the value of your loss function for different values of the 2 parameters $(w_1,w_2)$. The darker the color, the larger the loss value.</p>
        <div id="landscape_contour"></div>
        <div id="landscape_loss"></div>
    </div>
</div>

<p>The choice of optimizer influences both the speed of convergence and whether it occurs. Several alternatives to the classic gradient descent algorithms have been developed in the past few years and are listed in the table below. (Notation: dW = \frac{\partial \mathcal{L}}{\partial W}dW=∂W∂L​)</p>

<p>Adaptive optimization methods such as Adam or RMSprop perform well in the initial portion of training, but they have been found to generalize poorly at later stages  compared to Stochastic Gradient Descent. In Improving Generalization Performance by Switching from Adam to SGD, Keskar et al. investigate a hybrid strategy that begins training with an adaptive method and switches to SGD.</p>

<p>You can find more information about these optimizers in the Deep Learning Specialization Course 2: Improving your Deep Neural Network, Week 2 (Optimization) on Coursera.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Exploring optimization methods and hyperparameter values can help you build intuition for optimizing networks for your own tasks. During hyperparameter search, it’s important to understand intuitively the optimization’s sensitivity to learning rate, batch size, optimizer, and so on. That intuitive understanding, combined with the right method (random search or Bayesian optimization), will help you find the right model.</p>

